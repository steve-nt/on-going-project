================================================================================
                        LAB3 DELIVERABLES GUIDE
           Step-by-Step Instructions for Creating Project Deliverables
================================================================================

Based on the assignment requirements, this guide shows how to organize the
existing files into the three required deliverables.


================================================================================
                        ASSIGNMENT DELIVERABLES
================================================================================

The assignment requires three main deliverables:

1. CODE - Flask app, MITM relay, test scripts, README
2. ARTIFACTS - QR images, WebAuthn traces, logs, timing & cracking outputs
3. REPORT - Experiment setup, attack results, comparisons, recommendations


================================================================================
                    DELIVERABLE #1: CODE PACKAGE
================================================================================

WHAT TO INCLUDE:
All Python implementation files and documentation needed to run the system.

FILES TO PACKAGE:
---------------------------------------------------------------------------

Core Application Files:
  ✓ PersonA-app.py                    - Basic Flask API with password hashing
  ✓ PersonB-integrated_app.py         - Full Flask app with MFA integration
  
MFA Implementation:
  ✓ PersonB-mfa_totp.py               - TOTP implementation module
  ✓ PersonB-mfa_hotp.py               - HOTP implementation module
  ✓ PersonB-fido2_webauthn.py         - WebAuthn/FIDO2 implementation

Attack & Testing Scripts:
  ✓ PersonA-crack_passwords.py        - Password cracking demonstration
  ✓ PersonA-timing_attack.py          - Timing attack demo
  ✓ PersonB-dictionary_attack.py      - Dictionary/brute-force attacks
  ✓ PersonB-mitm_proxy.py             - MITM relay proxy

Testing Scripts:
  ✓ PersonA-testing.py                - API testing suite

Documentation:
  ✓ README.txt                        - Project overview and quick start
  ✓ EXECUTION-GUIDE.txt               - Detailed execution instructions
  ✓ Assigment-PersonA-PersonB.txt     - Original assignment

TOTAL: 12 files


HOW TO PACKAGE:
---------------------------------------------------------------------------

Option A - Create ZIP Archive:
  
  cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
  
  zip -r Lab3_Code_Deliverable.zip \
    PersonA-app.py \
    PersonB-integrated_app.py \
    PersonB-mfa_totp.py \
    PersonB-mfa_hotp.py \
    PersonB-fido2_webauthn.py \
    PersonA-crack_passwords.py \
    PersonA-timing_attack.py \
    PersonB-dictionary_attack.py \
    PersonB-mitm_proxy.py \
    PersonA-testing.py \
    README.txt \
    EXECUTION-GUIDE.txt \
    Assigment-PersonA-PersonB.txt


Option B - Create TAR Archive:
  
  cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
  
  tar -czf Lab3_Code_Deliverable.tar.gz \
    PersonA-app.py \
    PersonB-integrated_app.py \
    PersonB-mfa_totp.py \
    PersonB-mfa_hotp.py \
    PersonB-fido2_webauthn.py \
    PersonA-crack_passwords.py \
    PersonA-timing_attack.py \
    PersonB-dictionary_attack.py \
    PersonB-mitm_proxy.py \
    PersonA-testing.py \
    README.txt \
    EXECUTION-GUIDE.txt \
    Assigment-PersonA-PersonB.txt


Option C - Create Dedicated Folder:
  
  mkdir Lab3_Code_Deliverable
  
  cp PersonA-app.py Lab3_Code_Deliverable/
  cp PersonB-integrated_app.py Lab3_Code_Deliverable/
  cp PersonB-mfa_totp.py Lab3_Code_Deliverable/
  cp PersonB-mfa_hotp.py Lab3_Code_Deliverable/
  cp PersonB-fido2_webauthn.py Lab3_Code_Deliverable/
  cp PersonA-crack_passwords.py Lab3_Code_Deliverable/
  cp PersonA-timing_attack.py Lab3_Code_Deliverable/
  cp PersonB-dictionary_attack.py Lab3_Code_Deliverable/
  cp PersonB-mitm_proxy.py Lab3_Code_Deliverable/
  cp PersonA-testing.py Lab3_Code_Deliverable/
  cp README.txt Lab3_Code_Deliverable/
  cp EXECUTION-GUIDE.txt Lab3_Code_Deliverable/
  cp Assigment-PersonA-PersonB.txt Lab3_Code_Deliverable/


VERIFICATION:
---------------------------------------------------------------------------
Ensure the package includes:
  ✓ Main Flask applications (2 files)
  ✓ MFA modules (3 files)
  ✓ Attack/testing scripts (4 files)
  ✓ Testing suite (1 file)
  ✓ Documentation (3 files)
  ✓ Requirements: Flask, bcrypt, argon2-cffi, pyotp, qrcode, pillow, fido2


================================================================================
                    DELIVERABLE #2: ARTIFACTS PACKAGE
================================================================================

WHAT TO INCLUDE:
All generated outputs from running the code - QR codes, logs, traces, stats.

ARTIFACTS TO GENERATE:
---------------------------------------------------------------------------

Step 1: Generate QR Codes
  
  Run TOTP enrollment to generate QR codes:
  
  python3 PersonB-mfa_totp.py
  
  Generated files:
  ✓ qr_testuser_totp.png
  ✓ (Any other qr_<username>_totp.png files)


Step 2: Generate WebAuthn Traces
  
  Run WebAuthn implementation:
  
  python3 PersonB-fido2_webauthn.py
  
  Generated files:
  ✓ webauthn_logs.json (contains credential IDs, public keys, challenges)


Step 3: Generate MITM/Relay Logs
  

   Terminal 1 - Start Server

     cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
     python3 PersonB-integrated_app.py

   Terminal 2 - Start MITM Proxy

     cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
     python3 PersonB-mitm_proxy.py

   Terminal 3 - Execute These Commands

   Step 1 - Register:

     curl -X POST http://localhost:8080/register \
       -H "Content-Type: application/json" \
       -d '{"username":"testuser","password":"password123","hash_type":"bcrypt"}'

   Step 2 - Enroll TOTP (copy the secret!):

     curl -X POST http://localhost:8080/mfa/enroll/totp \
       -H "Content-Type: application/json" \
       -d '{"username":"testuser"}'

   Step 3 - Login (captures password):

     curl -X POST http://localhost:8080/login \
       -H "Content-Type: application/json" \
       -d '{"username":"testuser","password":"password123"}'

   Step 4a - Generate TOTP token:

      python3 -c "import pyotp; print('Token:', pyotp.TOTP('SECRET_FROM_STEP_2').now())"

   Step 4b - Send token (captures OTP):

     curl -X POST http://localhost:8080/mfa/verify \
       -H "Content-Type: application/json" \
       -d '{"username":"testuser","token":"YOUR_TOKEN_FROM_4a"}'

   Step 5 - Save logs:

     curl -X POST http://localhost:8080/proxy/save

   Step 6 - Verify:

     cat mitm_logs.json | python3 -m json.tool



Step 4: Generate Cracking Outputs
  
  Run password cracking analysis:
  
  python PersonB-dictionary_attack.py
  
  Generated files:
  ✓ cracking_report.txt (time-to-crack, success rates, hash comparisons)


  ===============================================================================
  UNDERSTANDING THE PASSWORD CRACKING SCRIPTS
  ===============================================================================
  
  PersonA-crack_passwords.py - Simple Brute Force Demo
  ---------------------------------------------------------------------------
  This script demonstrates basic brute-force password cracking.
  
  What it cracks:
    • Target password: "abc" (hardcoded in the script)
    • Hash algorithm: SHA-256 with 100,000 iterations
    • Salt: b"test_salt_16_bytes_"
    • Pepper: b"system_pepper_secret_key"
  
  How it works:
    • Character set: lowercase letters (a-z) + digits (0-9) = 36 characters
    • Max password length: 4 characters
    • Tries every combination systematically:
      1. 1-char: a, b, c, d, ..., z, 0, 1, ..., 9
      2. 2-char: aa, ab, ac, ..., zz, z0, ..., 99
      3. 3-char: aaa, aab, aac, ... until it finds "abc"
      4. Would continue to 4-char if needed
  
  Why it's slow:
    • Each attempt requires 100,000 SHA-256 iterations
    • Demonstrates how iteration rounds slow down attackers
    • "abc" is found after ~2000 attempts but still takes significant time
  
  To run:
    python PersonA-crack_passwords.py
  
  Note: This script takes a long time to complete due to 100,000 iterations.
        Be patient or reduce iterations in code for testing.
  
  
  PersonB-dictionary_attack.py - Comprehensive Cracking Demo
  ---------------------------------------------------------------------------
  This script demonstrates multiple attack types and algorithm comparisons.
  
  Test 1: Dictionary Attack
    • Target password: "password"
    • Method: Tries 30+ common passwords from built-in dictionary
    • Dictionary includes: password, 123456, qwerty, abc123, monkey,
      letmein, dragon, admin, welcome, etc.
    • Result: Finds "password" on first attempt (very fast)
  
  Test 2: Brute Force Attack
    • Target password: "ab1"
    • Method: Systematic brute force with max length 3
    • Character set: lowercase + digits (36 chars)
    • Tries: a, b, c, ..., aa, ab, ..., ab1
    • Result: Finds "ab1" after ~1300 attempts
  
  Test 3: Algorithm Comparison
    • Target password: "testpass"
    • Tests 4 hash algorithms:
      1. SHA-256 (100 rounds) - baseline
      2. SHA-3 (100 rounds) - similar speed to SHA-256
      3. bcrypt (8 rounds) - 500x slower than SHA-256
      4. Argon2 (time_cost=1, memory_cost=8192) - 1000x slower
    • Purpose: Shows relative cracking difficulty
    • Output: Time per hash for each algorithm
  
  Key Features:
    • Dictionary Attack - Fast for common passwords
    • Brute Force - Slow but finds any short password
    • Bcrypt/Argon2 Testing - Demonstrates resistance to cracking
    • Report Generation - Creates cracking_report.txt with full details
  
  To run:
    python PersonB-dictionary_attack.py
  
  Generated output:
    • Console: Real-time progress and results
    • File: cracking_report.txt with detailed analysis
  
  
  Comparison Summary
  ---------------------------------------------------------------------------
  ┌────────────┬───────────────────────┬──────────────────────────────────┐
  │ Feature    │ PersonA-crack_...     │ PersonB-dictionary_attack.py     │
  ├────────────┼───────────────────────┼──────────────────────────────────┤
  │ Complexity │ Simple, educational   │ Comprehensive, production-like   │
  │ Passwords  │ 1 password: "abc"     │ 3 test passwords                 │
  │ Methods    │ Brute force only      │ Dictionary + Brute + Comparison  │
  │ Algorithms │ SHA-256 only          │ SHA-256, SHA-3, bcrypt, Argon2   │
  │ Output     │ Console only          │ Console + cracking_report.txt    │
  │ Purpose    │ Basic brute force     │ Full cracking toolkit demo       │
  └────────────┴───────────────────────┴──────────────────────────────────┘
  
  
  Key Takeaways for Your Report
  ---------------------------------------------------------------------------
  Both scripts demonstrate:
  
  1. Dictionary attacks are FAST but only work on common passwords
     → "password" cracked instantly from dictionary
  
  2. Brute force is SLOW but eventually finds any password
     → Short passwords like "abc" and "ab1" still vulnerable
  
  3. Strong hashing makes cracking MUCH HARDER
     → bcrypt is 500x slower, Argon2 is 1000x slower than SHA-256
  
  4. Iteration count matters significantly
     → 100,000 rounds drastically slows attackers
  
  5. Password length and complexity are critical
     → "abc" (3 chars) much easier than "testpass" (8 chars)
  
  For your artifacts deliverable:
    • Include cracking_report.txt showing actual crack times
    • Reference these results in your report's attack analysis section
    • Demonstrate why bcrypt/Argon2 are recommended over SHA-256
  
  ===============================================================================


Step 5: Generate Timing Attack Data
  
  ===============================================================================
  TIMING ATTACK DEMONSTRATION
  ===============================================================================
  
  Purpose:
    Demonstrate timing side-channel vulnerability in naive string comparison
    vs. constant-time comparison (HMAC compare_digest).
  
  Command to run:
  ---------------------------------------------------------------------------
  cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
  python3 PersonA-timing_attack.py
  
  Or capture output to file:
  python3 PersonA-timing_attack.py > timing_attack_results.txt
  
  
  What the script tests:
  ---------------------------------------------------------------------------
  The script compares two comparison methods:
  
  1. NAIVE COMPARISON (Vulnerable):
     • Uses standard Python == operator
     • Stops comparing at first character mismatch
     • TIMING VARIES based on how many characters match
     • Security issue: Attacker can learn correct characters one by one
  
  2. SECURE COMPARISON (Safe):
     • Uses hmac.compare_digest()
     • Always checks entire string regardless of mismatches
     • CONSTANT TIME - same duration for any input
     • Security: No timing information leaks
  
  
  Test Cases Explained:
  ---------------------------------------------------------------------------
  Correct hash: "correct_password_hash_64_chars_long_aaaaaaaaaaaaaaaaaaaa"
  
  Test 1: "wrong_password_hash_64_chars_long_bbbbbbbbbbbbbbbbbbbbbb"
     • Differs from first character ('w' vs 'c')
     • Naive comparison fails IMMEDIATELY
     • Expected: FASTEST naive time
  
  Test 2: "correct_password_hash_64_chars_long_bbbbbbbbbbbbbbbbbbbbb"
     • Matches first 40 characters, then differs
     • Naive comparison checks 40 chars before failing
     • Expected: SLOWER naive time (more matches = more time)
  
  Test 3: "correct_password_hash_64_chars_long_aaaaaaaaaaaaaaaaaaab"
     • Matches all but last character
     • Naive comparison checks 63 chars before failing
     • Expected: SLOWEST naive time (almost complete match)
  
  
  Sample Output Interpretation:
  ---------------------------------------------------------------------------
  Test case 1:
  Naive avg: 1.43e-07 seconds    (0.000000143s - very fast, fails early)
  Secure avg: 2.12e-07 seconds   (0.000000212s - constant time)
  
  Test case 2:
  Naive avg: 1.26e-07 seconds    (0.000000126s - medium, checks more chars)
  Secure avg: 1.96e-07 seconds   (0.000000196s - constant time, similar)
  
  Test case 3:
  Naive avg: 1.34e-07 seconds    (0.000000134s - slowest naive, checks most)
  Secure avg: 1.92e-07 seconds   (0.000000192s - constant time, similar)
  
  
  Key Findings to Report:
  ---------------------------------------------------------------------------
  1. TIMING VARIANCE in Naive Comparison
     → Different test cases show different times
     → Time increases with number of matching characters
     → Attacker can exploit this to guess password character by character
  
  2. CONSTANT TIME in Secure Comparison
     → All test cases show SIMILAR times (~1.9-2.1e-07 seconds)
     → No correlation between matches and timing
     → Prevents timing side-channel attacks
  
  3. PERFORMANCE TRADE-OFF
     → Secure comparison is slightly slower (~50% overhead)
     → Security benefit FAR outweighs minimal performance cost
     → ALWAYS use hmac.compare_digest() for security-critical comparisons
  
  
  Real-World Attack Scenario:
  ---------------------------------------------------------------------------
  Without constant-time comparison, an attacker could:
  
  Step 1: Try all possible first characters (a-z, 0-9)
           Measure response time for each
           Correct character takes LONGER → reveals first char
  
  Step 2: Fix first character, try all second characters
           Again, time variation reveals correct second char
  
  Step 3: Continue until entire password/hash is discovered
  
  Result: Password cracked without brute force!
          Only N attempts needed (N = string length × charset size)
          Instead of N^M attempts (N = charset, M = length)
  
  
  For Your Artifacts:
  ---------------------------------------------------------------------------
  ✓ Save output to: timing_attack_results.txt
  ✓ Include in artifacts deliverable
  ✓ Reference in report's "Attack Mitigation" section
  ✓ Demonstrates importance of constant-time operations
  
  ===============================================================================


Step 6: Generate MFA Statistics
  
  ===============================================================================
  MFA STATISTICS GENERATION
  ===============================================================================
  
  Purpose:
    Collect statistics on TOTP/HOTP verification attempts to analyze
    success rates, time windows, and counter synchronization.
  
  
  How to Generate Statistics:
  ---------------------------------------------------------------------------
  
  Method 1: Run MFA tests through the integrated app
  
  Terminal 1 - Start server:
  cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
  python3 PersonB-integrated_app.py
  
  Terminal 2 - Test TOTP verification multiple times:
  # Register and enroll user first
  curl -X POST http://localhost:5000/register \
    -H "Content-Type: application/json" \
    -d '{"username":"statuser","password":"pass123","hash_type":"bcrypt"}'
  
  curl -X POST http://localhost:5000/mfa/enroll/totp \
    -H "Content-Type: application/json" \
    -d '{"username":"statuser"}'
  # Note the secret from response
  
  # Generate and test TOTP tokens
  python3 -c "import pyotp; print('Current token:', pyotp.TOTP('YOUR_SECRET_HERE').now())"
  # Replace 'YOUR_SECRET_HERE' with actual secret from enrollment
  
  # Verify token (repeat multiple times with different tokens)
  curl -X POST http://localhost:5000/mfa/verify \
    -H "Content-Type: application/json" \
    -d '{"username":"statuser","token":"TOKEN_HERE"}'
  
  
  Method 2: Run standalone TOTP test script (if available) It does not interact with server
  python3 PersonB-mfa_totp.py
  
  
  Generated Files:
  ---------------------------------------------------------------------------
  ✓ totp_stats.json - TOTP verification statistics
  ✓ hotp_stats.json - HOTP verification statistics (if HOTP tests run)
  
  
  Understanding totp_stats.json:
  ---------------------------------------------------------------------------
  
  Sample content:
  {
    "total_attempts": 3,           // Total TOTP verification attempts
    "successful": 2,               // Successful verifications
    "failed": 1,                   // Failed verifications
    "time_window_used": [
      {
        "timestamp": "2025-10-19T09:00:35.808140",
        "window": 0,               // Time window: 0 = exact time
        "status": "success"
      },
      {
        "timestamp": "2025-10-19T09:00:35.808449",
        "window": 1,               // Time window: 1 = ±30 seconds
        "status": "success"
      },
      {
        "timestamp": "2025-10-19T09:00:35.808855",
        "window": 1,
        "status": "failed"
      }
    ]
  }
  
  
  Key Metrics Explained:
  ---------------------------------------------------------------------------
  
  1. SUCCESS RATE
     → Calculation: successful / total_attempts
     → Example: 2/3 = 66.7% success rate
     → Interpretation: Shows how often valid tokens are accepted
     → High rate (>90%) = good user experience
     → Low rate (<80%) = possible time sync issues or user error
  
  2. TIME WINDOW ANALYSIS
     → Window 0: Only accepts tokens valid at current exact time
     → Window 1: Accepts tokens ±30 seconds from current time
     → Window 2: Accepts tokens ±60 seconds from current time
     → Trade-off: Larger window = better UX but weaker security
  
  3. FAILURE PATTERNS
     → Failed with window 0, success with window 1:
       → User's clock is slightly off-sync (within 30 seconds)
       → Recommendation: Use window=1 for production
     
     → Failed with window 1:
       → Expired token (>30 seconds old)
       → Wrong token entered
       → Clock severely out of sync
  
  
  Understanding hotp_stats.json (if generated):
  ---------------------------------------------------------------------------
  
  Sample content:
  {
    "total_attempts": 5,
    "successful": 4,
    "failed": 1,
    "counter_syncs": [
      {
        "timestamp": "2025-10-19T...",
        "expected_counter": 5,
        "actual_counter": 7,
        "resync_performed": true
      }
    ],
    "average_counter_drift": 1.2
  }
  
  Key HOTP Metrics:
  
  1. COUNTER SYNCHRONIZATION
     → HOTP uses an incrementing counter (not time-based)
     → Server and client must keep counters in sync
     → Drift occurs when token generation happens without verification
     → Example: User generates token but doesn't use it
  
  2. RESYNC EVENTS
     → When counter mismatch detected, server searches ahead
     → Typically looks ahead 10-50 counters
     → Resync successful = counter updated to match
     → Too many resyncs = usability problem
  
  3. AVERAGE DRIFT
     → Measures how far counter typically deviates
     → Low drift (<2) = good synchronization
     → High drift (>5) = users generating many unused tokens
  
  
  Database MFA Logs:
  ---------------------------------------------------------------------------
  
  Check MFA verification history in database:
  
  sqlite3 users.db "SELECT * FROM mfa_logs LIMIT 10;"
  
  Sample output:
  id|username|timestamp|mfa_type|success|details
  1|testuser_mitm|2025-10-19T11:46:12.057787|totp|1|
  2|statuser|2025-10-19T12:00:00.123456|totp|0|expired token
  3|statuser|2025-10-19T12:00:15.789012|totp|1|
  
  Columns explained:
  • id: Unique log entry ID
  • username: User who attempted verification
  • timestamp: When verification was attempted
  • mfa_type: totp, hotp, or webauthn
  • success: 1 = success, 0 = failure
  • details: Additional information (error messages, etc.)
  
  
  Analysis Commands:
  ---------------------------------------------------------------------------
  
  1. View TOTP statistics:
     cat totp_stats.json | python3 -m json.tool
  
  2. Calculate success rate:
     cat totp_stats.json | python3 -c "
     import json, sys
     d = json.load(sys.stdin)
     rate = d['successful'] / d['total_attempts'] * 100 if d['total_attempts'] > 0 else 0
     print(f'Success rate: {rate:.1f}%')
     print(f'Total attempts: {d[\"total_attempts\"]}')
     print(f'Successful: {d[\"successful\"]}')
     print(f'Failed: {d[\"failed\"]}')
     "
  
  3. Count MFA logs by type:
     sqlite3 users.db "
     SELECT mfa_type, 
            COUNT(*) as total,
            SUM(success) as successful
     FROM mfa_logs 
     GROUP BY mfa_type;
     "
  
  
  For Your Report:
  ---------------------------------------------------------------------------
  Use these statistics to demonstrate:
  
  1. TOTP USABILITY vs SECURITY
     → Show success rates with different time windows
     → Argue for window=1 (±30s) as balanced approach
  
  2. HOTP CHALLENGES
     → Document counter desync issues
     → Explain why TOTP is preferred over HOTP
  
  3. MFA EFFECTIVENESS
     → Show verification rates
     → Compare MFA vs non-MFA authentication
  
  ===============================================================================


Step 7: Capture Database State
  
  ===============================================================================
  DATABASE STATE CAPTURE
  ===============================================================================
  
  Purpose:
    Preserve database snapshot showing user accounts, password hashes,
    MFA enrollment data, and verification logs.
  
  
  Command to Capture Database:
  ---------------------------------------------------------------------------
  cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3
  cp users.db artifacts_users.db
  
  This creates a backup copy for your artifacts deliverable.
  
  
  Understanding Database Schema:
  ---------------------------------------------------------------------------
  
  View database structure:
  sqlite3 users.db ".schema"
  
  Output shows two tables:
  
  TABLE 1: users
  ---------------------------------------------------------------------------
  CREATE TABLE users (
    username TEXT PRIMARY KEY,        -- Unique username
    salt BLOB,                        -- Random salt for password hashing
    hash BLOB,                        -- Hashed password
    hash_type TEXT,                   -- Hash algorithm: bcrypt, sha256, etc.
    mfa_enabled INTEGER DEFAULT 0,    -- 1 = MFA enabled, 0 = disabled
    mfa_type TEXT,                    -- MFA method: totp, hotp, webauthn
    totp_secret TEXT,                 -- TOTP secret key (base32 encoded)
    hotp_secret TEXT,                 -- HOTP secret key
    hotp_counter INTEGER DEFAULT 0,   -- HOTP counter value
    webauthn_credentials TEXT         -- WebAuthn credential data (JSON)
  );
  
  TABLE 2: mfa_logs
  ---------------------------------------------------------------------------
  CREATE TABLE mfa_logs (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Log entry ID
    username TEXT,                         -- User who attempted MFA
    timestamp TEXT,                        -- When attempt occurred
    mfa_type TEXT,                         -- Type: totp/hotp/webauthn
    success INTEGER,                       -- 1 = success, 0 = failed
    details TEXT                           -- Additional info/errors
  );
  
  
  Inspecting Database Contents:
  ---------------------------------------------------------------------------
  
  1. View all users and their configurations:
     sqlite3 users.db "
     SELECT username, hash_type, mfa_enabled, mfa_type 
     FROM users;
     "
     
     Example output:
     testuser_mitm|bcrypt|1|totp
     statuser|sha256|0|
     admin|argon2|1|webauthn
  
  2. Count users by hash algorithm:
     sqlite3 users.db "
     SELECT hash_type, COUNT(*) as count 
     FROM users 
     GROUP BY hash_type;
     "
     
     Example output:
     bcrypt|5
     sha256|2
     argon2|3
  
  3. Count users with MFA enabled:
     sqlite3 users.db "
     SELECT 
       COUNT(*) as total_users,
       SUM(CASE WHEN mfa_enabled=1 THEN 1 ELSE 0 END) as mfa_users,
       SUM(CASE WHEN mfa_enabled=0 THEN 1 ELSE 0 END) as no_mfa_users
     FROM users;
     "
     
     Example output:
     total_users|mfa_users|no_mfa_users
     10|7|3
  
  4. View MFA enrollment breakdown:
     sqlite3 users.db "
     SELECT mfa_type, COUNT(*) as count 
     FROM users 
     WHERE mfa_enabled=1 
     GROUP BY mfa_type;
     "
     
     Example output:
     totp|5
     hotp|1
     webauthn|1
  
  5. View recent MFA verification attempts:
     sqlite3 users.db "
     SELECT username, timestamp, mfa_type, success 
     FROM mfa_logs 
     ORDER BY timestamp DESC 
     LIMIT 10;
     "
     
     Example output:
     testuser_mitm|2025-10-19T11:46:12|totp|1
     statuser|2025-10-19T12:00:00|totp|0
     statuser|2025-10-19T12:00:15|totp|1
  
  6. Calculate MFA success rate:
     sqlite3 users.db "
     SELECT 
       COUNT(*) as total_attempts,
       SUM(success) as successful,
       ROUND(SUM(success) * 100.0 / COUNT(*), 2) as success_rate_pct
     FROM mfa_logs;
     "
     
     Example output:
     total_attempts|successful|success_rate_pct
     15|13|86.67
  
  
  Export Database to Readable Format:
  ---------------------------------------------------------------------------
  
  1. Export as SQL dump:
     sqlite3 users.db .dump > database_dump.sql
  
  2. Export users table as CSV:
     sqlite3 users.db -csv -header "SELECT * FROM users;" > users.csv
  
  3. Export MFA logs as CSV:
     sqlite3 users.db -csv -header "SELECT * FROM mfa_logs;" > mfa_logs.csv
  
  4. Generate database summary report:
     cat > database_summary.txt << 'EOF'
     DATABASE SUMMARY REPORT
     =======================
     
     EOF
     
     echo "Total Users:" >> database_summary.txt
     sqlite3 users.db "SELECT COUNT(*) FROM users;" >> database_summary.txt
     
     echo -e "\nHash Algorithm Distribution:" >> database_summary.txt
     sqlite3 users.db "SELECT hash_type, COUNT(*) FROM users GROUP BY hash_type;" >> database_summary.txt
     
     echo -e "\nMFA Enrollment:" >> database_summary.txt
     sqlite3 users.db "SELECT mfa_type, COUNT(*) FROM users WHERE mfa_enabled=1 GROUP BY mfa_type;" >> database_summary.txt
     
     echo -e "\nMFA Verification Stats:" >> database_summary.txt
     sqlite3 users.db "SELECT COUNT(*) as attempts, SUM(success) as successful FROM mfa_logs;" >> database_summary.txt
  
  
  What to Include in Artifacts:
  ---------------------------------------------------------------------------
  ✓ artifacts_users.db - Copy of database with test data
  ✓ database_summary.txt - Human-readable summary
  ✓ Optional: users.csv, mfa_logs.csv for easy viewing
  
  
  For Your Report:
  ---------------------------------------------------------------------------
  Use database data to show:
  
  1. PASSWORD HASHING IMPLEMENTATION
     → Show users with different hash algorithms (bcrypt, Argon2, SHA-256)
     → Demonstrate salt storage (per-user salt in database)
     → Prove pepper usage (not stored, only in code)
  
  2. MFA DEPLOYMENT
     → X% of users have MFA enabled
     → TOTP is most common (Y users)
     → WebAuthn adoption (Z users)
  
  3. SECURITY METRICS
     → MFA success rate: N%
     → Authentication logs show verification patterns
     → Failed attempts tracked for security monitoring
  
  4. SCHEMA DESIGN
     → Separation of concerns (users vs logs)
     → Proper data types (BLOB for binary data, TEXT for strings)
     → Indexing on username (PRIMARY KEY) for fast lookups
  
  ===============================================================================


COMPLETE ARTIFACTS LIST:
---------------------------------------------------------------------------

QR Images:
  ✓ qr_testuser_totp.png
  ✓ qr_<username>_totp.png (for each enrolled user)

WebAuthn Traces:
  ✓ webauthn_logs.json
    - Registration challenges and responses
    - Credential IDs
    - Public keys
    - Authentication events

MITM/Relay Logs:
  ✓ mitm_logs.json
    - Captured credentials
    - Intercepted OTP tokens
    - Relay success/failure rates
    - Timing measurements (latency)

Cracking Outputs:
  ✓ cracking_report.txt
    - Dictionary attack results
    - Brute-force timings
    - Hash algorithm comparisons
    - Success rates per algorithm

Timing Attack Results:
  ✓ timing_attack_results.txt
    - Naive comparison timings
    - Constant-time comparison timings
    - Statistical analysis
    - Mitigation effectiveness

MFA Statistics:
  ✓ totp_stats.json
  ✓ hotp_stats.json
  ✓ mfa_logs table in database

Database:
  ✓ artifacts_users.db (snapshot of database with test data)


HOW TO PACKAGE:
---------------------------------------------------------------------------

Option A - Create ZIP Archive:
  
  # First generate all artifacts by running the scripts above
  
  zip -r Lab3_Artifacts_Deliverable.zip \
    qr_*.png \
    webauthn_logs.json \
    mitm_logs.json \
    cracking_report.txt \
    timing_attack_results.txt \
    totp_stats.json \
    hotp_stats.json \
    artifacts_users.db


Option B - Create Dedicated Folder:
  
  mkdir Lab3_Artifacts_Deliverable
  
  # Copy all generated artifacts
  cp qr_*.png Lab3_Artifacts_Deliverable/
  cp webauthn_logs.json Lab3_Artifacts_Deliverable/
  cp mitm_logs.json Lab3_Artifacts_Deliverable/
  cp cracking_report.txt Lab3_Artifacts_Deliverable/
  cp timing_attack_results.txt Lab3_Artifacts_Deliverable/
  cp totp_stats.json Lab3_Artifacts_Deliverable/
  cp hotp_stats.json Lab3_Artifacts_Deliverable/
  cp users.db Lab3_Artifacts_Deliverable/artifacts_users.db
  
  # Create README for artifacts
  cat > Lab3_Artifacts_Deliverable/ARTIFACTS_README.txt << 'EOF'
ARTIFACTS DESCRIPTION
=====================

This folder contains all generated artifacts from the authentication
security implementation and attack demonstrations.

QR Codes (qr_*.png):
- TOTP enrollment QR codes for authenticator apps
- Generated during MFA enrollment

WebAuthn Logs (webauthn_logs.json):
- FIDO2 registration and authentication traces
- Contains credential IDs, public keys, challenges

MITM Logs (mitm_logs.json):
- Captured credentials and OTP tokens
- Relay success/failure data
- Timing measurements

Cracking Report (cracking_report.txt):
- Password cracking analysis
- Time-to-crack for different hash algorithms
- Dictionary and brute-force results

Timing Attack Results (timing_attack_results.txt):
- Timing leakage measurements
- Naive vs constant-time comparison benchmarks

MFA Statistics (totp_stats.json, hotp_stats.json):
- Verification attempt logs
- Success/failure rates
- Time window and counter data

Database (artifacts_users.db):
- SQLite database with test users
- Shows schema and MFA metadata
EOF


VERIFICATION:
---------------------------------------------------------------------------
Ensure the package includes:
  ✓ At least one QR code image
  ✓ WebAuthn traces with credential data
  ✓ MITM relay logs showing capture
  ✓ Cracking report with timings
  ✓ Timing attack analysis
  ✓ MFA statistics files
  ✓ Database snapshot


================================================================================
                    DELIVERABLE #3: REPORT PACKAGE
================================================================================

WHAT TO INCLUDE:
Comprehensive written analysis covering experiment setup, results, comparisons,
and recommendations.

FILES TO INCLUDE:
---------------------------------------------------------------------------

Primary Reports:
  ✓ PersonA-Report.txt                - Person A's detailed analysis
  ✓ PersonB-Report.txt                - Person B's comprehensive report
  ✓ PersonA-Task-Completion-Report.txt - Person A completion analysis
  ✓ PersonB-Task-Completion-Summary.txt - Person B completion summary

Supporting Documentation:
  ✓ PersonA.txt                       - Person A documentation
  ✓ README.txt                        - Project overview

TOTAL: 6 files


REPORT CONTENT MAPPING:
---------------------------------------------------------------------------

The existing report files already cover all required sections:

1. EXPERIMENT SETUP:
   Location: PersonA-Report.txt (Section on Password Storage)
   Location: PersonB-Report.txt (Section 2: Experimental Setup)
   
   Covers:
   ✓ Testing environment
   ✓ Hash algorithm configurations
   ✓ Cost parameters (bcrypt rounds, Argon2 memory)
   ✓ MFA setup (TOTP/HOTP/WebAuthn)

2. ATTACK RESULTS:
   Location: PersonA-Report.txt (Cracking & Timing sections)
   Location: PersonB-Report.txt (Section 3: Attack Analysis)
   
   Covers:
   ✓ Success rates for dictionary attacks
   ✓ Time-to-crack measurements
   ✓ Timing attack measurements
   ✓ MITM relay success/failure

3. SALT/PEPPER EFFECTS:
   Location: PersonA-Report.txt (Salt & Pepper Analysis section)
   Location: PersonA-Task-Completion-Report.txt (Task 3 analysis)
   
   Covers:
   ✓ Per-user salt benefits
   ✓ System pepper impact
   ✓ Rainbow table resistance
   ✓ Cracking difficulty comparison

4. MFA COMPARISON:
   Location: PersonB-Report.txt (Section 1.2: MFA)
   Location: PersonB-Task-Completion-Summary.txt (Tasks 1-2)
   
   Covers:
   ✓ HOTP vs TOTP comparison
   ✓ Counter desync handling
   ✓ Time window trade-offs
   ✓ FIDO2/WebAuthn advantages
   ✓ Relay attack resistance

5. MITIGATIONS & RECOMMENDATIONS:
   Location: PersonA-Report.txt (HMAC & Integrity section)
   Location: PersonB-Report.txt (Section 4: Security Recommendations)
   
   Covers:
   ✓ Constant-time comparison
   ✓ HMAC for integrity
   ✓ Optimal hash parameters
   ✓ MFA deployment strategies
   ✓ Defense-in-depth approach

6. DEMO EVIDENCE:
   Reference to: Artifacts package
   
   Shows:
   ✓ Screenshots/logs of TOTP relay success
   ✓ WebAuthn relay failure (origin binding)
   ✓ Captured MITM logs
   ✓ Visual QR codes


HOW TO PACKAGE:
---------------------------------------------------------------------------

Option A - Create ZIP Archive:
  
  zip -r Lab3_Report_Deliverable.zip \
    PersonA-Report.txt \
    PersonB-Report.txt \
    PersonA-Task-Completion-Report.txt \
    PersonB-Task-Completion-Summary.txt \
    PersonA.txt \
    README.txt


Option B - Create Dedicated Folder:
  
  mkdir Lab3_Report_Deliverable
  
  cp PersonA-Report.txt Lab3_Report_Deliverable/
  cp PersonB-Report.txt Lab3_Report_Deliverable/
  cp PersonA-Task-Completion-Report.txt Lab3_Report_Deliverable/
  cp PersonB-Task-Completion-Summary.txt Lab3_Report_Deliverable/
  cp PersonA.txt Lab3_Report_Deliverable/
  cp README.txt Lab3_Report_Deliverable/
  
  # Create master report index
  cat > Lab3_Report_Deliverable/REPORT_INDEX.txt << 'EOF'
LAB3 REPORT DELIVERABLE - READING GUIDE
========================================

This package contains comprehensive analysis and documentation of the
authentication security implementation project.

RECOMMENDED READING ORDER:
--------------------------

1. README.txt
   Start here for project overview and quick reference

2. PersonB-Report.txt (40 KB - Most comprehensive)
   Complete theoretical and experimental analysis
   Covers: MFA theory, attack analysis, security recommendations
   Sections:
   - Section 1: Theoretical Foundations
   - Section 2: Implementation Details  
   - Section 3: Experimental Analysis
   - Section 4: Security Recommendations

3. PersonA-Report.txt (19 KB - Implementation focused)
   Detailed coverage of password hashing and integrity
   Covers: SHA-256, SHA-3, bcrypt, Argon2, salt/pepper, HMAC
   Includes: Cracking results, timing attack analysis

4. PersonA-Task-Completion-Report.txt
   Task-by-task completion analysis for Person A's work
   Shows mapping from requirements to implementation

5. PersonB-Task-Completion-Summary.txt
   Task-by-task completion analysis for Person B's work
   Lists all deliverables and file descriptions

6. PersonA.txt
   Additional Person A documentation and notes

REPORT SECTIONS MAPPED TO ASSIGNMENT REQUIREMENTS:
---------------------------------------------------

Experiment Setup:
→ PersonB-Report.txt - Section 2
→ PersonA-Report.txt - Testing sections

Attack Results (success rates, timings):
→ PersonB-Report.txt - Section 3
→ PersonA-Report.txt - Cracking & timing sections
→ Refer to Artifacts package for raw data

Salt/Pepper Effects:
→ PersonA-Report.txt - Salt & Pepper Analysis
→ PersonA-Task-Completion-Report.txt - Task 3

MFA Comparison (HOTP vs TOTP vs FIDO2):
→ PersonB-Report.txt - Section 1.2 and Section 3
→ PersonB-Task-Completion-Summary.txt - Tasks 1-2

Mitigations & Deployment Recommendations:
→ PersonB-Report.txt - Section 4
→ PersonA-Report.txt - HMAC section

Demo Evidence:
→ Reference artifacts package for screenshots and logs
→ MITM logs show TOTP relay success vs WebAuthn failure
EOF


Option C - Create Consolidated Report:
  
  # Combine all reports into single master document
  cat > Lab3_Master_Report.txt << 'EOF'
================================================================================
                 LAB3 AUTHENTICATION SECURITY PROJECT
                        COMPREHENSIVE REPORT
================================================================================

This report consolidates findings from both Person A and Person B's work
on the authentication security implementation and attack analysis project.

TABLE OF CONTENTS:
1. Project Overview
2. Person A: Core API & Security Foundations
3. Person B: MFA, Attacks & Mitigations
4. Experimental Results & Analysis
5. Conclusions & Recommendations

================================================================================
SECTION 1: PROJECT OVERVIEW
================================================================================
EOF
  
  cat README.txt >> Lab3_Master_Report.txt
  
  echo -e "\n\n" >> Lab3_Master_Report.txt
  echo "================================================================================" >> Lab3_Master_Report.txt
  echo "SECTION 2: PERSON A - CORE API & SECURITY FOUNDATIONS" >> Lab3_Master_Report.txt
  echo "================================================================================" >> Lab3_Master_Report.txt
  
  cat PersonA-Report.txt >> Lab3_Master_Report.txt
  
  echo -e "\n\n" >> Lab3_Master_Report.txt
  echo "================================================================================" >> Lab3_Master_Report.txt
  echo "SECTION 3: PERSON B - MFA, ATTACKS & MITIGATIONS" >> Lab3_Master_Report.txt
  echo "================================================================================" >> Lab3_Master_Report.txt
  
  cat PersonB-Report.txt >> Lab3_Master_Report.txt
  
  echo -e "\n\n" >> Lab3_Master_Report.txt
  echo "================================================================================" >> Lab3_Master_Report.txt
  echo "SECTION 4: COMPLETION ANALYSIS" >> Lab3_Master_Report.txt
  echo "================================================================================" >> Lab3_Master_Report.txt
  
  cat PersonA-Task-Completion-Report.txt >> Lab3_Master_Report.txt
  cat PersonB-Task-Completion-Summary.txt >> Lab3_Master_Report.txt


VERIFICATION:
---------------------------------------------------------------------------
Ensure the package includes:
  ✓ Experiment setup documentation
  ✓ Attack results with success rates and timings
  ✓ Salt/pepper analysis
  ✓ MFA comparison (HOTP/TOTP/FIDO2)
  ✓ Mitigation strategies
  ✓ Deployment recommendations
  ✓ Demo evidence references


================================================================================
                    COMPLETE DELIVERABLE CHECKLIST
================================================================================

DELIVERABLE #1: CODE ✓
---------------------------------------------------------------------------
Files to Package:
  [ ] PersonA-app.py
  [ ] PersonB-integrated_app.py
  [ ] PersonB-mfa_totp.py
  [ ] PersonB-mfa_hotp.py
  [ ] PersonB-fido2_webauthn.py
  [ ] PersonA-crack_passwords.py
  [ ] PersonA-timing_attack.py
  [ ] PersonB-dictionary_attack.py
  [ ] PersonB-mitm_proxy.py
  [ ] PersonA-testing.py
  [ ] README.txt
  [ ] EXECUTION-GUIDE.txt
  [ ] Assigment-PersonA-PersonB.txt

Verification:
  [ ] All Python files present
  [ ] Documentation included
  [ ] Dependencies listed in README
  [ ] Execution instructions provided


DELIVERABLE #2: ARTIFACTS ✓
---------------------------------------------------------------------------
Files to Generate & Package:
  [ ] QR code images (qr_*.png)
  [ ] webauthn_logs.json
  [ ] mitm_logs.json
  [ ] cracking_report.txt
  [ ] timing_attack_results.txt
  [ ] totp_stats.json
  [ ] hotp_stats.json
  [ ] artifacts_users.db

Verification:
  [ ] All artifacts generated by running code
  [ ] QR codes are valid PNG images
  [ ] JSON files are well-formed
  [ ] Logs contain meaningful data
  [ ] Database contains test users


DELIVERABLE #3: REPORT ✓
---------------------------------------------------------------------------
Files to Package:
  [ ] PersonA-Report.txt
  [ ] PersonB-Report.txt
  [ ] PersonA-Task-Completion-Report.txt
  [ ] PersonB-Task-Completion-Summary.txt
  [ ] PersonA.txt
  [ ] README.txt
  
Optional:
  [ ] REPORT_INDEX.txt (reading guide)
  [ ] Lab3_Master_Report.txt (consolidated)

Verification:
  [ ] Covers experiment setup
  [ ] Includes attack results
  [ ] Analyzes salt/pepper effects
  [ ] Compares MFA methods
  [ ] Provides mitigation strategies
  [ ] References demo evidence


================================================================================
                    QUICK DELIVERY COMMANDS
================================================================================

STEP 1: Create all three deliverables at once
---------------------------------------------------------------------------

cd /home/steven/Desktop/on-going-project/v1-D7076E-Lab3

# Create Code deliverable
zip -r Lab3_Code_Deliverable.zip \
  PersonA-app.py PersonB-integrated_app.py \
  PersonB-mfa_totp.py PersonB-mfa_hotp.py PersonB-fido2_webauthn.py \
  PersonA-crack_passwords.py PersonA-timing_attack.py \
  PersonB-dictionary_attack.py PersonB-mitm_proxy.py \
  PersonA-testing.py \
  README.txt EXECUTION-GUIDE.txt Assigment-PersonA-PersonB.txt

# Generate artifacts (run the necessary scripts first)
# Then package artifacts
zip -r Lab3_Artifacts_Deliverable.zip \
  qr_*.png *_logs.json *_stats.json \
  cracking_report.txt timing_attack_results.txt \
  users.db

# Create Report deliverable
zip -r Lab3_Report_Deliverable.zip \
  PersonA-Report.txt PersonB-Report.txt \
  PersonA-Task-Completion-Report.txt PersonB-Task-Completion-Summary.txt \
  PersonA.txt README.txt


STEP 2: Verify deliverables
---------------------------------------------------------------------------

ls -lh Lab3_*_Deliverable.zip

unzip -l Lab3_Code_Deliverable.zip
unzip -l Lab3_Artifacts_Deliverable.zip
unzip -l Lab3_Report_Deliverable.zip


STEP 3: Create master submission package (optional)
---------------------------------------------------------------------------

mkdir Lab3_Complete_Submission
mv Lab3_*_Deliverable.zip Lab3_Complete_Submission/

cat > Lab3_Complete_Submission/SUBMISSION_README.txt << 'EOF'
LAB3 AUTHENTICATION SECURITY PROJECT - COMPLETE SUBMISSION
===========================================================

This submission contains three required deliverables:

1. Lab3_Code_Deliverable.zip
   - All Python implementation files
   - Attack and testing scripts
   - Documentation and execution guides

2. Lab3_Artifacts_Deliverable.zip
   - Generated QR codes for TOTP
   - WebAuthn registration traces
   - MITM/relay logs
   - Password cracking results
   - Timing attack measurements
   - MFA statistics

3. Lab3_Report_Deliverable.zip
   - Comprehensive analysis reports
   - Experiment setup and results
   - Salt/pepper analysis
   - MFA comparison
   - Security recommendations

Extract each ZIP file to access the contents.
Refer to README.txt and EXECUTION-GUIDE.txt in the Code deliverable
for instructions on running the system.
EOF

zip -r Lab3_Complete_Submission.zip Lab3_Complete_Submission/


================================================================================
                            FINAL NOTES
================================================================================

IMPORTANT REMINDERS:
---------------------------------------------------------------------------

1. Generate artifacts BEFORE packaging them
   - Run all Python scripts to create logs, stats, and outputs
   - Capture timing attack output to text file
   - Ensure database contains test data

2. Test code package independently
   - Extract to fresh directory
   - Install dependencies: pip install flask bcrypt argon2-cffi pyotp qrcode pillow fido2 requests
   - Verify all scripts run successfully

3. Report references artifacts
   - Ensure artifact filenames match report references
   - Include screenshots of key demonstrations if required
   - Cross-reference between report and artifact files

4. All assignment requirements are covered
   - Flask REST API ✓
   - 4 password hashing algorithms ✓
   - Salt & pepper ✓
   - HMAC integrity ✓
   - TOTP & HOTP ✓
   - FIDO2/WebAuthn ✓
   - Password cracking ✓
   - Timing attacks ✓
   - MITM relay ✓

5. File organization matches assignment split
   - Person A: Core API & Security Foundations
   - Person B: MFA, Attacks & Mitigations
   - All tasks completed and documented


================================================================================
                            END OF GUIDE
================================================================================
